Небольшая помощь по лабе. "Базовая" настройка вашего конфига Apache и всякая фигня.
Для начала соберите ваш jar. Если вы используйте gradle, то все просто.
Команда: ./gradlew build (для первой сборки)
./gradlew clean build (для всех последующих)

Выберите два каких-нибудь незанятых порта > 1024, рекомендую соседние, отличающиеся на 1,
например, у меня это 24036 и 24037.
В дальнейшем объяснении буду использовать их для наглядности

На 24036 у вас будет сидеть Apache.
Для этого в httpd.conf, скачанный с se.ifmo.ru, измените строки:
Listen 24000, на Listen 24036
ServerName helios.cs.ifmo.ru:24000, на ServerName helios.cs.ifmo.ru:24036

На 24037 у вас будет сидеть FastCGI.
Для этого в httpd.conf измените строку:
FastCgiExternalServer "/home/studs/sXXXXXX/httpd-root/fcgi-bin/hello-world.jar" -host localhost:24001 -nph
На FastCgiExternalServer "/home/studs/sXXXXXX/httpd-root/fcgi-bin/hello-world.jar" -host localhost:24037 -nph
В этой же строке не забудьте указать имя вашего jar-ника (вместо /hello-world.jar у меня /labwork1.jar)

Естественно, в httpd.conf также нужно изменить все sXXXXXX на sИСУ (у меня s466730)
Также нужно изменить DocumentRoot "/var/www" и <Directory "/var/www"> на ваш путь к frontend.
У меня будет DocumentRoot "/home/studs/s466730/httpd-root/static"
и <Directory "/home/studs/s466730/httpd-root/static"> соответственно.

На этом общая настройка httpd.conf как бы завершена. Все остальные изменения зависят от вас.

Теперь о том, как подключится к вашим портам правильно.
Для этого используйте cmd или подобное. Вводите следующее:
ssh -p 2222 -L 8080:localhost:24036 s466730@helios.cs.ifmo.ru
Не забудьте поменять порт и ИСУ
После введения пароля создавайте где-нибудь ваш httpd-root и начинайте создавать там директории
(conf, mutex-dir, fcgi-bin, static [ваш фронт])
В conf кидайте ваш httpd.conf. В fcgi-bin кидайте ваш jar-ник.

После всего этого можно запускать ваш проект.
Вот команды:
httpd -f ~/httpd-root/conf/httpd.conf -k start
java -DFCGI_PORT=24037 -jar labwork1.jar

Очевидно, у вас могут быть другие пути к конфигу и джарнику, не забудьте про порт
Ну тип все. Вводите localhost:8080 и смотрите что у вас там за ошибка ))

Не забывайте после каждого исправления в java коде пересобирать джарник и закидывать его на хелиос.
Аналогично про фронт: что-то тронули, снова кидайте обнову на хелиос

Теперь чуть-чуть харда:
Вместо java -DFCGI_PORT=24037 -jar labwork1.jar я использую команду ~/httpd-root/fcgi-bin/run-java.sh restart.
Вообще, run-java.sh - это service manager для Java FastCGI-сервера.
Далее объяснения от GPT:

1. Его назначение — удобно запускать ваше Java-приложение в фоновом режиме как постоянно работающий процесс (демон),
а также останавливать, перезапускать и проверять его статус, решая проблему ручного управления процессом.


2. Подробное объяснение
Как мы обсуждали ранее, FastCGI-процесс должен работать постоянно, независимо от веб-сервера. Но это порождает вопросы:

Как запустить Java-приложение так, чтобы оно не остановилось, когда вы закроете терминал?
Как узнать, работает ли оно сейчас?
Как корректно его остановить, не убивая процесс вручную каждый раз?
Как хранить логи его работы?
Именно эти задачи и решает скрипт run-java.sh. Он превращает ваше простое .jar приложение в полноценную фоновую службу.

Давайте разберем его ключевые части:

Конфигурация (переменные в начале):

JAVA, APP_JAR: Указывают путь к Java и вашему приложению.
FCGI_PORT: Определяет порт, который будет слушать ваше Java-приложение.
PID_FILE: Путь к файлу, где будет храниться ID процесса (PID) запущенного приложения.
Это ключевой элемент для управления.
LOG_FILE: Файл, куда будут записываться все сообщения и ошибки от вашего Java-приложения.

Функция start():

Проверяет, не запущен ли уже процесс (с помощью PID_FILE и команды kill -0).
Запускает Java-приложение с помощью команды: nohup "$JAVA" ... &
nohup ... &: Запускает процесс в фоновом режиме (&) и делает его независимым от текущей сессии терминала (nohup).
Теперь можно закрыть консоль, а сервер продолжит работать.
-DFCGI_PORT="$FCGI_PORT": Передает порт в ваше Java-приложение как системное свойство.
Ваш Java-код может прочитать это свойство, чтобы понять, на каком порту ему нужно "слушать" запросы.
>> "$LOG_FILE" 2>&1: Перенаправляет весь вывод (и стандартный, и ошибки) в лог-файл.
echo $! > "$PID_FILE": Критически важная строка. Она берет ID только что запущенного процесса ($!)
и записывает его в PID_FILE. Теперь скрипт знает, какой именно процесс нужно останавливать.

Функция stop():

Читает ID процесса из PID_FILE.
Аккуратно пытается остановить процесс командой kill (сигнал SIGTERM).
Если процесс не останавливается в течение 10 секунд, он принудительно "убивает" его командой kill -9 (сигнал SIGKILL).
Удаляет PID_FILE.

Функции status() и restart():

status: Просто проверяет, жив ли процесс с ID из PID_FILE.
restart: Удобная команда, которая просто выполняет stop, а затем start.
case "$1" in ...:
Это диспетчер команд. Он смотрит на первый аргумент, который вы передали скрипту (./run-java.sh start),
и вызывает соответствующую функцию.


3. Аналогия или простой пример
Представьте, что ваше Java-приложение — это электрогенератор в подвале дома.

Вы можете просто запустить его вручную, и он будет работать. Но если вы уйдете,
вы не будете знать, работает ли он еще, не перегрелся ли, и как его безопасно выключить на расстоянии.
Скрипт run-java.sh — это пульт управления этим генератором, установленный на первом этаже.

Кнопка "START" (start): Запускает генератор, зажигает зеленую лампочку и записывает в журнал время запуска.
Если он уже работает, кнопка ничего не делает.
Кнопка "STOP" (stop): Отправляет генератору команду на плавное выключение.
Если он не реагирует, активирует аварийное отключение.
Индикатор "STATUS" (status): Зеленая лампочка, которая горит, если генератор работает, и не горит, если он выключен.
Кнопка "RESTART" (restart): Просто нажимает "STOP", а затем "START".
Этот пульт делает управление сложным устройством в подвале простым, безопасным и предсказуемым.


4. Связь с моей лабораторной работой
Этот скрипт является сердцем операционной части вашего бэкенда.

Без него вам пришлось бы каждый раз вручную вводить в консоль длинную команду nohup java -jar ... &,
затем вручную искать PID процесса (ps aux | grep java), чтобы его остановить,
и вручную проверять, работает ли он. Это неудобно и чревато ошибками.

Скрипт run-java.sh автоматизирует и стандартизирует все эти действия.

Вы запускаете бэкенд командой: ./run-java.sh start
Вы проверяете его работу: ./run-java.sh status
Вы останавливаете его: ./run-java.sh stop
Вы применяете изменения в коде (после пересборки .jar файла): ./run-java.sh restart
Он является оберткой над вашим Java FastCGI-сервером,
которая превращает его из просто "запускаемого файла" в управляемую службу (демон),
что является стандартной практикой для развертывания серверных приложений в Linux-окружении.

На этом все, удачки